Terraform Questions:

What is Meant by Null Resources:
1: A null resource is a special resource type allows you to define a resource block with no direct counter part in the underlying infrastructure
2: it is often used when you need to perform some arbitrary action or execute a provisioner without creating any tangible infrastructure resource

Use Cases:
1: When you want to execute the local exec
2: when you want to call external apis
3: Running custom logic during the terraform lifecycle

What is Terraform Validate command:
1: Validate command used to check the validations of resources
2: Terraform validate commands is used to validate the configuration files in a project are syntactically valid and internally consistent

How to Create a Resources Using a Loop:
1: Count
count = 2
2: For Each
for each argument must be map or set of strings
it will not take Tuple as a type of Argument

Method 1:
count = 2
var.name[count.index]
Method 2:
variables file
variable "sub" {
  type = set(string)
  default = ["10.1.0.0/24","10.2.0.0/24"]
}

for_each = var.sub
sub = each.value

How to Create a Resources Conditionally:
using the condition like ternary operator
count = var.env == "dev/qa" ? 1 : 0

variable == "value" ? 1 : 0

What are Data Sources:

Data sources allow you to fetch and reference data from external sources or existing infrastructure

data "aws_ami" "latest_amazon_linux" {
  most_recent = true

  owners = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

data "vault_generic_secrets" "data_base_secrets" {
  path = "secret/data/database"
}

resource "aws_db_instance" "example" {
  username = data.vault.generic_secrets.data_base_secrets.credentials.data["username"]
  password = data.vault_generic_secrets.data_base_secrets.credentials["password"]
}

variable "example_password" {
  type = string
  description = "A Sensitive Variable"
  sensitive = true
}

locals "aws_instance" {
  value =
}

What are local Variable:
These are type of Variable where we cannot

How to Delete particular resources in terraform:
1: terraform destroy -target=resource.name

What resources can be Set variables in with VPC,AutoScaling, LoadBalancer:
AWS VPC : CIDR as Variable
AutoScaling: desired_capacity as Variable
LoadBalancer: LoadBalancer name as variable

How to provide variable at cli:
When declaring variables at tf vars don't pass any default value then it will ask user to enter

Terraform Modules:
Used for Bigger project for consistency
module_name/
  ├── main.tf
  ├── variables.tf
  ├── outputs.tf
  └── README.md (optional)

1: Reusability
2: Abstraction
3: Maintainability
4: Versioning
5: Collaboration

Organization Standards to use terraform:

1: Directory Structure : Root Directory
/my_terraform_project
  ├── main.tf
  ├── variables.tf
  ├── outputs.tf # Shows Values required in terminal
  ├── terraform.tfvars #Variable values for each environment.
  ├── provider.tf
  ├── modules/
  ├── environments/
  └── README.md
2: Use of Modules
3: Variables, inputs, Locals
4: Outputs and Documentation
5: State Management remote backend
6: Naming Conventions : projectname_resource
7: Providers and Authentication
8: Code Review and Collaboration
9: Continuous integration and Continuous Deployment
10: Security Considerations
11: Logging and Monitoring

VPC ,EC2,Cloud Trail,IAM
1: IAM Will Create
2: VPC
3: EC2
4: Cloud Trail

Import Command:

import {
  to = aws_iot_thing.bar
  id = "foo"
}
terraform plan -generate-config-out=generated.tf

Drawbacks of terraform:
1: Error Handling
2: Json and HCL

Terraform Version: 1.5
Hashicorp AWS Version: 5.8.0

Now Terraform Version: 1.7 or 1.8
Now HashiCorp Version: 5.34.0

# How to Manage Secrets in Terraform:

1: Use sensitive keyword in variables section
2: Use AWS SSM Parameters --> Data sources
3: Use Hashi-Corp Vault --> using data sources
4: Environment Variables --> /tmp/password.txt
5: Pass Variables in .tfvars

Using Data Sources we can leverage the automation for secrets management

1: Using Variables files

variable "database_password" {
  type        = string
  sensitive   = true
  description = "Password for the database"
}
2: AWS Systems Manager Parameters Store or Secrets Manager:

retrieve sensitive information such as passwords, API keys, or other credentials

data "aws_ssm_parameter" "database_password" {
  name = "/myapp/database_password"
}

resource "aws_instance" "example" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"

  user_data = <<-EOF
              #!/bin/bash
              echo "Database Password: ${data.aws_ssm_parameter.database_password.value}" > /tmp/password.txt
              EOF
}

3: External Secrets Management: Hashi-Corp Vault

provider "vault" {
  address = "https://vault.example.com:8200"
  token   = "your_vault_token"
}

data "vault_generic_secret" "database_credentials" {
  path = "secret/myapp/database"
}

resource "aws_instance" "example" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"

  user_data = <<-EOF
              #!/bin/bash
              echo "Database Username: ${data.vault_generic_secret.database_credentials.data["username"]}" > /tmp/username.txt
              echo "Database Password: ${data.vault_generic_secret.database_credentials.data["password"]}" > /tmp/password.txt
              EOF
}

4: Using Environment Variables:

variable "database_password" {
  type = string
}

resource "aws_instance" "example" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"

  user_data = <<-EOF
              #!/bin/bash
              echo "Database Password: $DATABASE_PASSWORD" > /tmp/password.txt
              EOF
}

You have a Parent Module and Child Module :
Using terraform workspaces
Terraform is platform agnostic
1: terraform workspace new dev
2: terraform workspace select dev
3: Modules
4: terraform apply -var-file=dev.tfvars

Scenarios:

End To End Terraform Flow
1: First Write Tf files
2: Terraform init
3: Terraform validate
4: Terraform plan
5: Terraform fmt --> Write Canonical Form mostly used in Import

One Particular Resource needs to be recreated :
1: Using terraform taint we can create a particular resource in next apply command

Terraform tain is command used to represent that particular resource is degraded or upgraded or damaged need to be replaced in next apply

1: Terraform state list
2: terraform taint "resources_name"
3: terraform apply

terraform taint and untaint

terraform taint is deprecated instead we use

terraform apply --replace=<resource-name>

# One Particular resource needs to be deleted:

terraform destroy -target=aws_instance.my_instance

# Explain the various types of meta-arguments:

Meta arguments changes the default behaviors of terraform configuration

1: depends_on[list of resources]
2: count
3: for_each
4: provider
provider "aws" {
  alias  = "europe"
  region = "europe-west1"
}
resource "aws" "name" {
  provider = aws.europe
}

5: lifecycle -- > create_before_destroy
lifecycle {
    create_before_destroy = true
    ignore_changes = [tags["Name"],]
    prevent_destroy =
    replace_triggered_by = [aws_ecs_service.svc.id]
  }

# Who Created terraform.tfstate.backup file
terraform destroy command will create the backup file
it is because that to restore the infra to the same state

# Force Unlock --> Manually delete lock on terraform file
terraform apply --force-unlock

# Terraform Refresh
1: When ever there is a mismatch in terraform statefile we run this command

Built-In Functions:

lookup(map,key,default) : Returns default value if the key/value not present
lookup({"a" = 1, "b" = 2}, "b", 0)  # Result: 2
lookup({"a" = 1, "b" = 2}, "c", 0)  # Result: 0

tolist(set) : Converts set to list
tolist(["a", "b", "c"])  # Result: ["a", "b", "c"]

lower(string) : Converts string lower to upper
upper(string) : Converts string upper to lower

Element(list,index): return element at given index
element(["a", "b", "c"], 1)  # Result: "b"

# Interview Session - 1:

Components used in creating the terraform:
1: VPC
2: Subnets
3: s3
4: IAM
5: Kubernetes
6: VMs

How to do changes in the already created configuration :

Using " Terraform import " command we can do changes which are already created.

State file is get and stored:
Locally or Remote Backend

If we loose state file:  There is no way to get back so we need to lock and save it in Storage

Terraform Validate: used to validate the syntax
Terraform fmt

Types of Modules in terraform:

1: Root Module: Main Module to be called with all configurations
2: Child Module: called with in the root module and get created based on the structure
3: Module Sources: Modules can be sourced from various locations.

Remote Backend: Used for Locking and storing

How to pass variable over run time:
variable.tf
variable "aws" {
  type = string
}

How to Manage Modules in Multiple Environments:
using terraform workspace

Traditional IT Infra:
1: Slow Deployment
2: Expensive
3: Limited Automation
4: Human Error
5: Wasted Resources
6: Inconsistency

Terraform Providers:
Terraform Provider is a Plugin that lets terraform managers an external api
when we run terraform init plugin required for the provider are automatically downloaded and saved locally

Resource Block :
Describe one or more infrastructure objects

Hashi-Corp Maintained: No need Required Providers section

Non Hashi-Corp Maintained: Need to provide required_providers Section

terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "5.22.12"
    }
  }
}

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "resource_name" {
  ami = "ami_id"
  instance_type="t2.micro"
}

How to debug and troubleshoot the terraform:
1: terraform init and terraform debug
2: terraform init
3: terraform validate
4: terraform fmt
5: terraform plan -debug (enable debug output gives detailed info about the terraform doing)
6: terraform state (terraform show)
7: increase verbosity using trace command
TF_LOG=TRACE terraform plan
8: to check the function issues we use terraform console
9: terraform init -upgrade

Terraform fmt:
document some commonly accepted formatting guidelines for terraform code these conventions can e enforced automatically with terraform fmt

Configuration Syntax in terraform:
1: Arguments key value pairs
2: Blocks are used to mention resources
3: identifiers = terraform specific constructs like resources,input variables,etc .. are all identifiers
4: Comments # // /**/






1. GitOps
2. CI/CD Pipelines
3. Kubernetes
4. Infrastructure as Code (IaC)
5. Cloud-Native Applications
6. Microservices Architecture
7. Security in DevOps
8. Monitoring and Observability
9. DevSecOps
10. Automation