Write some Code for Providers:
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "5.22.0"
    }
  }
}
provider "aws" {
  alias = "us-east"
  region = "us-east-1"
}

resource "aws_instance" "Jenkins" {
  ami = "ami_id"
  instance_type = "t2.micro"
  security_groups =
  key_pair =
}

Locals: # Locals
locals {
  environment_name = "production"
}
Data-Sources: # Data Sources
data "aws_ami" "latest_amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}
variables: # Variables
variable "region" {
  type    = string
  default = "us-west-2"
}

variable "instance_types" {
  type    = list(string)
  default = ["t2.micro", "t2.small", "t2.medium"]
}
life-cycle: # Resources
resource "aws_instance" "ec2_instances" {
  count         = length(var.instance_types)
  instance_type = var.instance_types[count.index]
  ami           = data.aws_ami.latest_amazon_linux.id
  tags          = local.tags

# Life Cycle
  lifecycle {
    create_before_destroy = true
    prevent_destroy       = false
  }
}
for:
# For Loop Example
resource "aws_s3_bucket" "example_buckets" {
  count         = 3
  bucket        = "example-bucket-${count.index}"
  acl           = "private"
  force_destroy = true
}

for-each:
# For Each Loop Example
variable "vpc_cidrs" {
  type    = map(string)
  default = {
    "us-west-1" = "10.0.0.0/16"
    "us-east-1" = "10.1.0.0/16"
    "eu-west-1" = "10.2.0.0/16"
  }
}
resource "aws_vpc" "vpcs" {
  for_each = var.vpc_cidrs

  cidr_block = each.value
  tags       = {
    Name = "VPC-${each.key}"
  }
}
dynamic block: # Dynamic Block Example
variable "additional_tags" {
  type = map(string)
  default = {
    app = "web"
    env = "prod"
  }
}

# resource "aws_instance" "dynamic_tags" {
#   count = 2
#   ami   = data.aws_ami.latest_amazon_linux.id
#   tags = merge(
#     local.tags,
#     {
#       Name = "instance-${count.index + 1}"
#     },
#     var.additional_tags
#   )
#   }

Condition :
# Condition Example
resource "aws_security_group" "example_sg" {
  name        = "example_sg"
  description = "Example Security Group"

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = var.region == "us-west-2" ? ["0.0.0.0/0"] : []
  }
}

Resource:
# Data Sources
data "aws_ami" "latest_amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

# Resources

resource "aws_instance" "ec2_instances" {
  count         = length(var.instance_types)
  instance_type = var.instance_types[count.index]
  ami           = data.aws_ami.latest_amazon_linux.id
  tags          = local.tags

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = false
    ignore_changes = ["tags", "metadata"]
    ignore_changes_on_replace = ["volume_size"]
  }
}

Depends on :

1: Reduced Parallelism
2: Hard-Coding Dependencies
3: Increased Complexity

resource "aws_instance" "example" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
  # other resource configurations
  depends_on = [aws_s3_bucket.example_bucket]
}

resource "aws_s3_bucket" "example_bucket" {
  bucket = "example-bucket"
  acl    = "private"
  # other resource configurations
}


Terraform Provisioners:
1: Local Exec Provisioners: commands will execute locally on the machine where terraform is executed
resource ""

resources "ec2_instances" "example" {
  ami = "ami"
  instance_type = "t2.micro"
  provisioner "local-exec" {
    command = "echo 'provisioned only oif count is even"
    when = var.count%2 == 0
  }
}
2: Remote Exec: Commands will be run at a remote machines
resources "ec2_instances" "example"{
  ami = "ami"
  instance_type = "t2.micro"
provisioner "remote-exec" {
  inline = [
    "sudo apt-get update"
    "sudo apt-get install -y nginx"
  ]
 }
}

3: File Provisioner:
resource "ec2_instance" "example" {
  ami = "ami"
  instance_type = "t2.micro"
  provisioner "file" {
    src = "local/path"
    destination = "remote path"
  }
}

Assertion in Terraform:
variables {
  bucket_prefix = "test"
}
run "valid_string_concat" {
  command = plan
  assert {
    condition = aws_s3_bucket.bucket.bucket == "test-bucket"
    error_message = "S3 bucket"
  }
}

Different Types of Build in Functions:
1: String Functions
2: Numeric Functions
3: Collection Functions
4: Encoding Functions
5: File System Functions
6: Data and Time Functions
7: Hash and Crypto Functions
8: Ip Network Functions
9: Type Conversion Functions

Most Used Functions in Terraform:
1: length (create based on availability zones)
2: slice (create based on slice)
3: merge (variables)
4: min
5: max
6: base64encode
7: base64decode
8: concatenation: two or more list combines into a single task
9: contains:

Diff Between For_each and Dynamic block:
both are used to create a multiple instance of a nested block
for_each will work with all kind of data types
list,sets,maps,objects
Dynamic Block will work for list and sets

for each is easy when compared to Dynamic Block

provider "aws" {
  region = "us-east-1"
}

resources "ec_instance" "first" {
  ami = "ami"
  instance_type = "t2.micro"

  dynamic "setting" {
    for_each = var.sq_ingress_rules
    content {
      namespace = setting.value['description']
      name = setting.value['name']
      value = setting.value['value']
    }
  }
}

local {
  default = {

  }
}








